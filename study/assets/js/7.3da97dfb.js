(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{144:function(t,n,e){t.exports=e.p+"assets/img/distributed.289ee13f.png"},188:function(t,n,e){"use strict";e.r(n);var a=[function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("div",{staticClass:"content"},[a("h2",{attrs:{id:"git基础操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git基础操作","aria-hidden":"true"}},[t._v("#")]),t._v(" git基础操作")]),t._v(" "),a("h3",{attrs:{id:"什么是git"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是git","aria-hidden":"true"}},[t._v("#")]),t._v(" 什么是git")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://git-scm.com/book/en/v2/images/centralized.png",alt:""}}),t._v(" "),a("img",{attrs:{src:e(144),alt:""}})]),t._v(" "),a("h4",{attrs:{id:"_1-创建仓库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-创建仓库","aria-hidden":"true"}},[t._v("#")]),t._v(" 1 - 创建仓库")]),t._v(" "),a("pre",[a("code",[t._v(" Git init：在一个文件目录执行该指令，会把该目录快速设置成Git的代码仓库。\n-- Git clone：从远程服务器clone工程，也会创建一个代码仓库。\n")])]),t._v(" "),a("h4",{attrs:{id:"_2-提交修改"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-提交修改","aria-hidden":"true"}},[t._v("#")]),t._v(" 2 - 提交修改")]),t._v(" "),a("pre",[a("code",[t._v("git status \n查看当前仓库状态。会提示那些文件发生修改，哪些内容需要add&commit。\n\ngit add 文件名 \n添加文件到仓库\ngit commit -m “这里是注释” \n将add的文件添加注释并且提交到代码仓库\ngit log \n  能查看到刚才提交的信息\ngit shortlog\n\n将开发者操作按照姓名分组\n\ngit commit –amend -m “这里是追加的注释，会覆盖上次的注释”\n\n如果上一个注释写错，可以这样进行修改和追加。\n")])]),t._v(" "),a("h4",{attrs:{id:"_3-diff比较不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-diff比较不同","aria-hidden":"true"}},[t._v("#")]),t._v(" 3 - diff比较不同")]),t._v(" "),a("pre",[a("code",[t._v("git diff ReadMe.txt(文件名)\n\n显示指定内容的前后变化\n\ngit diff HEAD\n\n显示出上次提交节点的差别\n\ngit还支持第三方更强大的diff工具：Meld、beyond compare\n\ngitk \n图形化的log记录\n")])]),t._v(" "),a("h4",{attrs:{id:"_4-别名设置，简化log"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-别名设置，简化log","aria-hidden":"true"}},[t._v("#")]),t._v(" 4-别名设置，简化log")]),t._v(" "),a("pre",[a("code",[t._v("`git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset-%C(yellow)%d%Creset%s%Cgreen(%cr)%C(bold blue)\n2-Git操作区域\nGit三个区域：工作区(开发修改代码区域)、暂存区、历史区(保存各个版本区域)\n\n暂存区：Git根目录下 > .git > index的文件中，保存了所有的代码提交记录。\n\nadd操作就是将记录保存到暂存区，此时Head依然指向之前的内容，通过commit将暂存区的内容全部提交，之后Head指向最新内容(通过gitk查看)\n\nGit管理的是修改内容，而不是文件\n3-Git回退\ngit checkout ReadMe.txt(文件名) \n将未add提交的修改内容全部还原 \n如果执行add后修改的内容，执行该指令会修改到执行好add后\n\ngit checkout – ReadMe.txt(文件名)\n\n能将add提交的内容都回退掉\n\ngit reset HEAD ReadMe.txt(文件名)\n\n文件从暂存区回退到工作区\n")])]),t._v(" "),a("h4",{attrs:{id:"_5-回退版本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-回退版本","aria-hidden":"true"}},[t._v("#")]),t._v(" 5 - 回退版本")]),t._v(" "),a("pre",[a("code",[t._v("git reset –hard HEAD~1 \n回退一个版本\n\ngit reset –hard HEAD~5\n\n回退5个版本()\n\nhard参数：不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码也回退到这个版本。\n\n也可以通过commit ID回退到对应版本。\n")])]),t._v(" "),a("h4",{attrs:{id:"_6-操作历史"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-操作历史","aria-hidden":"true"}},[t._v("#")]),t._v(" 6 - 操作历史")]),t._v(" "),a("pre",[a("code",[t._v("git reflog \n可以查看所有操作的历史！\n")])]),t._v(" "),a("h4",{attrs:{id:"_7-文件操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-文件操作","aria-hidden":"true"}},[t._v("#")]),t._v(" 7 - 文件操作")]),t._v(" "),a("pre",[a("code",[t._v("git rm ReadMe.txt(文件名) \n删除文件\n")])]),t._v(" "),a("h4",{attrs:{id:"_8-文件暂存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-文件暂存","aria-hidden":"true"}},[t._v("#")]),t._v(" 8 - 文件暂存")]),t._v(" "),a("pre",[a("code",[t._v("在main分支上开发功能的时候，开发到一半，发现了以前的BUG，这时新建一个BUG分支，在上面修复BUG。但是因为main分支开发的功能开发到一半，会导致BUG分支无法编译通过。这时候可以用`git stash`暂存当前的修改。在修改前的分支作为新的BUG分支。等解决BUG后切换回main分支的时候，再把暂存的内容Pop出来。 先checkout一个BUG分支，修改BUG后，用`git merge`合并到master分支，并且删除了BUG分支。这时候回到main分支，通过`git stash`pop出之前暂存的内容。\ngit stash \n暂存\ngit stash list \n查看当前暂存内容\ngit stash apply/pop \n内容恢复，后者会删除记录，前者可以通过git stash drop删除暂存记录。\n")])]),t._v(" "),a("p",[t._v("9-远程仓库\nGit本地仓库和Git远程仓库通信，需要SSH进行身份认证。\nssh-keygen -t rsa -C “yourname@example.com”")]),t._v(" "),a("pre",[a("code",[t._v("创建SSH私钥和公钥 \nid_rsa私钥用于验证自己身份。id_rsa.pub公钥用于向服务器表明自己的身份。\n\ngit remote add\n\n将本地代码库提交到远程仓库\n\ngit push -u origin master\n\n将本地master分支提交到远程的master分支，并关联起来。\n\ngit pull –rebase\n\n如果Apush修改前，B push了修改，A push的时候需要先从远程获取最新修改。这个指令不会产生过多的merge历史。\n\ngit clone git地址 \n就能从远程仓库clone下来，新建一个本地仓库。\n")])]),t._v(" "),a("h4",{attrs:{id:"_10-分支管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-分支管理","aria-hidden":"true"}},[t._v("#")]),t._v(" 10 - 分支管理")]),t._v(" "),a("pre",[a("code",[t._v("git checkout -b first\n\n创建新分支，并且切换到该分支，等价于： \ngit brach first创建分支 \ngit checkout first切换分支 \n如果此时有未提交的修改，是无法切换分支的，这时候就可以用git stash进行暂存\n\ngit branch\n\n查看分支 \n-r显示所有远程分支，-a显示所有本地分支和远程分支\n\n(master)git merge first\n\n在first分支进行修改、add、commit后，切换到master分支，合并第一个分支到master分支。\n\nmerge和rebase，rebase操作后时间线会合并，merge不会。其余都是一样的。\n\ngit branch -d first\n\n删除分支first。-d是删除分支，-D是强行删除分支。\n\ngit remote origin\n\n查看远程分支\n\ngit remote -v origin\n\n查看详细信息\n\ngit checkout -b dev\n\ngit push origin dev \n将dev分支推送到远程仓库。\n\n\n一般项目有一个中央的分支，用于打tag和发布realse版本。会新建一个develop分支进行开发，每个开发者再从develop分支新建自己的分支，功能完成后会merge到develop分支。 git add/commit 是分别从工作区，到暂存区，再到版本区。 git push用于版本区到远程仓库。 远程仓库获取最新内容是git pull到工作区 版本区到工作区是git checkout HEAD 暂存区到工作区是git checkout\n8-Tag\nTag用于记录某个commit点或者分支的历史快照。Tag通常打在Master分支上，以保证代码的准确性。\ngit tag version1 \n创建Tag，会记录在最后的提交上\n\ngit tag version2 commitID(commit点的ID) \n在commitID点加上tag\ngit tag\n\n查看所有Tag\n\ngit tag -a v1 -m “vesion1” b87123665216321635173\n\n-a制定tag名字，-m制定注释文字\n\ngit show tag名字\n\n显示tag的详细信息\n\ngit tag -d version0\n\n删除tag\n\ngit push origin version0\n\n推送tag到远程仓库\n\ngit push origin –tags\n\n推送所有本地tag到远程仓库\n\n删除远程Tag\n\n删除本地tag，再重新push到远程代码库。\n")])])])}],i=e(0),r=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},a,!1,null,null,null);r.options.__file="README.md";n.default=r.exports}}]);